<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<style>
canvas 
{
		border:1px solid #d3d3d3;
		background-color: #f1f1f1;
}
		</style>
		<!--
			https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/adapter.js
			https://github.com/webrtc/adapter/tree/master/release
		-->
		<script src="adapter.js"></script>
	</head>
	<body onload="startup()">
		<button id="connectButton">
			Create
		</button>
		<button id="joinButton">
			Join
		</button>
		<button id="disconnectButton" disabled>
			Disconnect
		</button>
		<div class="messagebox">
			<label for="message">Enter a message:
				<input type="text" name="message" id="message" placeholder="Message text"
						inputmode="latin" size=60 maxlength=120 disabled>
			</label>
			<button id="sendButton" name="sendButton" class="buttonright" disabled>
				Send
			</button>
		</div>
		<div class="messagebox" id="receivebox">
			<p>Messages received:</p>
		</div>
		
		
		<script>
/** 
 * https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample
 */
function startup() {
	connectButton = document.getElementById('connectButton');
	joinButton = document.getElementById('joinButton');
	disconnectButton = document.getElementById('disconnectButton');
	sendButton = document.getElementById('sendButton');
	messageInputBox = document.getElementById('message');
	receiveBox = document.getElementById('receivebox');
	
	// Set event listeners for user interface widgets
	connectButton.addEventListener('click', connectPeers, false);
	joinButton.addEventListener('click', joinExisting, false);
	disconnectButton.addEventListener('click', disconnectPeers, false);
	sendButton.addEventListener('click', sendMessage, false);
}
function connectPeers() {
	// Set up the local peer
	localConnection = new RTCPeerConnection();
	remoteConnection = null;
	//https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createDataChannel
	//Setting "negotiated: false" (or leaving it out) will automatically trigger the RTCPeerConnection to handle the negotiations for you, causing the remote peer to create a data channel and linking the two together across the network.
	const dataChannelOptions = {
		ordered: true, //If the data channel should guarantee order or not
		//maxPacketLifeTime: 3000, //The maximum time to try and retransmit a failed message in milliseconds
		//maxRetransmits: 2, //The maximum number of times to try and retransmit a failed message
		//protocol: 'slime-soccer-protocol', //Allows a subprotocol to be used which provides meta information towards the application
		//negotiated: false, //If set to true, it removes the automatic setting up of a data channel on the other peer, meaning that you are provided your own way to create a data channel with the same id on the other side
		//id: '???', //Allows you to provide your own ID for the channel (can only be used in combination with negotiated set to true)
	};
	sendChannel = localConnection.createDataChannel("sendChannel", dataChannelOptions);
	sendChannel.onopen = handleSendChannelStatusChange;
	sendChannel.onclose = handleSendChannelStatusChange;

	// set up ICE candidates
	//Note: In a real-world scenario in which the two peers aren't running in the same context, the process is a bit more involved; each side provides, one at a time, a suggested way to connect (for example, UDP, UDP with a relay, TCP, etc.) by calling RTCPeerConnection.addIceCandidate(), and they go back and forth until agreement is reached. But here, we just accept the first offer on each side, since there's no actual networking involved.
	localConnection.onicecandidate = function(event) {
		console.log('local onicecandidate', event);
		if (event.candidate) {
			remoteConnection.addIceCandidate(event.candidate)
				.catch((e) => console.error(e));
		}
	};
	
	//https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Connectivity
	//Start the connection attempt by hosting
	localConnection.createOffer() //3. create an SDP (Session Description Protocol) blob describing the connection we want to make
		.then(offer => {
			localConnection.setLocalDescription(offer); //4. configure the local end of the connection.
			//5. ask STUN servers to generate the ice candidates
			makeAjaxCall(
				'http://slime.glenwatson.me/serverPost.php?unique=1234',
				'POST',
				offer.sdp		
			); //6. uses the signaling server to transmit the offer to the intended receiver of the call.
			// start polling for an answer
			return startPollingForSdpAnswer(); //12. The caller receives the answer.
		})
		.then((answer) => localConnection.setRemoteDescription(new RTCSessionDescription({sdp: answer, type: 'answer'}))) //13. Call setRemoteDescription() to set the answer as the remote description for its end of the call. It now knows the configuration of both peers.
		.catch((e) => console.error(e));
}
function joinExisting() {
	localConnection = new RTCPeerConnection();
	remoteConnection = null;
	getOffer()
		.then((offer) => localConnection.setRemoteDescription(new RTCSessionDescription({sdp: offer, type: 'offer'}))) //7. Receive the offer and calls RTCPeerConnection.setRemoteDescription() to record it as the remote description (the description of the host)
		.then(() => localConnection.createAnswer()) //8-9. Create an answer by calling RTCPeerConnection.createAnswer().
		.then((answer) => {
			localConnection.setLocalDescription(answer); //10. Call RTCPeerConnection.setLocalDescription(), passing in the created answer, to set the answer as its local description. The recipient now knows the configuration of both ends of the connection.
			makeAjaxCall(
				'http://slime.glenwatson.me/serverPost.php?unique=5678',
				'POST',
				answer.sdp
			); //11. Use the signaling server to send the answer to the caller.
		})
		.catch((e) => console.error(e));
}
function startPollingForSdpAnswer() {
	var delay = 1000;
	var retryString = 'retry: ';
	return new Promise((resolve, reject) => {
		function doPoll() {
			console.log('polling for answer with delay', delay);
			setTimeout(() => {
				makeAjaxCall(
					'http://slime.glenwatson.me/serverGet.php?unique=1234',
					'POST'
				).then((response) => {
					if (response.startsWith(retryString)) {
						//server controlled retry delay
						delay = parseInt(response.substr(retryString.length));
						doPoll();
					} else {
						console.log('Got an answer!');
						resolve(response);
					}
				}).catch((e) => console.error(e));
			}, delay);
		};
		doPoll();
	});
}
function getOffer() {
	return makeAjaxCall(
		'http://slime.glenwatson.me/serverGet.php?unique=5678',
		'GET'
	);
};
function makeAjaxCall(url, method, data) {
	var xhr = new XMLHttpRequest();
	var promise = new Promise((resolve, reject) => {
		xhr.onload = function() {
			if (xhr.status === 200) {
				// If successful, resolve the promise by passing back the xhr response
				resolve(xhr.response);
			} else {
				// If it fails, reject the promise with a error message
				reject(Error('Image did not load successfully; error code:' + xhr.statusText));
			}
		};
		xhr.onerror = function() {
			// Also deal with the case when the entire request fails to begin with
			// This is probably a network error, so reject the promise with an appropriate message
			reject(Error('There was a network error.'));
		};
	});
	xhr.open(method, url, true);
	xhr.send(data);
	return promise;
}

function receiveChannelCallback(event) {
	console.log('remote ondatachannel', event);
	receiveChannel = event.channel;
	receiveChannel.onmessage = handleReceiveMessage;
	receiveChannel.onopen = handleReceiveChannelStatusChange;
	receiveChannel.onclose = handleReceiveChannelStatusChange;
}
function handleSendChannelStatusChange(event) {
	console.log('local handleSendChannelStatusChange', event);
	if (!sendChannel) {
		return;
	}
	var state = sendChannel.readyState;

	if (state === "open") { //finished establishing the link between the two peers
		messageInputBox.disabled = false;
		messageInputBox.focus();
		sendButton.disabled = false;
		disconnectButton.disabled = false;
		connectButton.disabled = true;
	} else { //"closed"
		messageInputBox.disabled = true;
		sendButton.disabled = true;
		connectButton.disabled = false;
		disconnectButton.disabled = true;
	}
}
function handleReceiveChannelStatusChange(event) {
	if (receiveChannel) {
		console.log("Receive channel's status has changed to " + receiveChannel.readyState);
	}
}
function disconnectPeers() {
	console.log('disconnecting peers');
	// Close the RTCDataChannels if they're open.
	sendChannel.close();
	receiveChannel.close();
	
	// Close the RTCPeerConnections
	localConnection.close();

	sendChannel = null;
	receiveChannel = null;
	localConnection = null;
	
	// Update user interface elements
	connectButton.disabled = false;
	disconnectButton.disabled = true;
	sendButton.disabled = true;
	messageInputBox.value = "";
	messageInputBox.disabled = true;
}
function sendMessage() {
	var message = messageInputBox.value;
	sendChannel.send(message);
	
	messageInputBox.value = "";
	messageInputBox.focus();
}
function handleReceiveMessage(event) {
	console.log('recieve channel onmessage', event);
	var el = document.createElement("p");
	var txtNode = document.createTextNode(event.data);
	
	el.appendChild(txtNode);
	receiveBox.appendChild(el);
}
function handleLocalAddCandidateSuccess() {
	connectButton.disabled = true;
}

function handleRemoteAddCandidateSuccess() {
	disconnectButton.disabled = false;
}
		</script>
	</body>
</html>