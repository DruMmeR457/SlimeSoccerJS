<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<style>
		</style>
		<!--
		WebRTC shim
			https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/adapter.js
			https://github.com/webrtc/adapter/tree/master/release
		-->
		<script src="adapter.js"></script>
	</head>
	<body onload="startup()">
		<button id="connectButton">
			Create
		</button>
		<button id="joinButton">
			Join
		</button>
		<button id="disconnectButton" disabled>
			Disconnect
		</button>
		<div class="messagebox">
			<label for="message">Enter a message:
				<input type="text" name="message" id="message" placeholder="Message text"
						inputmode="latin" size=60 maxlength=120 disabled>
			</label>
			<button id="sendButton" name="sendButton" class="buttonright" disabled>
				Send
			</button>
		</div>
		<div class="messagebox" id="receivebox">
			<p>Messages received:</p>
		</div>
		
		
		<script>
var STUN_SERVERS = [
	{url: 'stun:stun.l.google.com:19302'}
];
/** 
 * https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample
 */
function startup() {
	connectButton = document.getElementById('connectButton');
	joinButton = document.getElementById('joinButton');
	disconnectButton = document.getElementById('disconnectButton');
	sendButton = document.getElementById('sendButton');
	messageInputBox = document.getElementById('message');
	receiveBox = document.getElementById('receivebox');
	
	// Set event listeners for user interface widgets
	connectButton.addEventListener('click', createOfferAndPollForAnswer, false);
	joinButton.addEventListener('click', joinExisting, false);
	disconnectButton.addEventListener('click', disconnectPeers, false);
	sendButton.addEventListener('click', sendMessage, false);
}
function createOfferAndPollForAnswer() {
	// Set up the local peer
	localConnection = new RTCPeerConnection({iceServers: STUN_SERVERS});
	//https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createDataChannel
	//Setting "negotiated: false" (or leaving it out) will automatically trigger the RTCPeerConnection to handle the negotiations for you, causing the remote peer to create a data channel and linking the two together across the network.
	const dataChannelOptions = {
		ordered: true, //If the data channel should guarantee order or not
		//maxPacketLifeTime: 3000, //The maximum time to try and retransmit a failed message in milliseconds
		//maxRetransmits: 2, //The maximum number of times to try and retransmit a failed message
		//protocol: 'slime-soccer-protocol', //Allows a subprotocol to be used which provides meta information towards the application
		//negotiated: false, //If set to true, it removes the automatic setting up of a data channel on the other peer, meaning that you are provided your own way to create a data channel with the same id on the other side
		//id: '???', //Allows you to provide your own ID for the channel (can only be used in combination with negotiated set to true)
	};
	dataChannel = localConnection.createDataChannel("dataChannel", dataChannelOptions);
	dataChannel.onmessage = handleReceiveMessage
	//update the UI on connect/disconnect
	dataChannel.onopen = handleDataChannelStatusChange;
	dataChannel.onclose = handleDataChannelStatusChange;

	// set up ICE candidates
	//onicecandidate() is automatically called by the browser with candidates once the localConnection is started
	localConnection.onicecandidate = function(event) {
		console.log('local onicecandidate', event);
		if (event.candidate) {
			makeAjaxCall(
				'http://slime.glenwatson.me/serverPost.php?unique=1234',
				'POST',
				JSON.stringify({type:'ice_candidate', candidate: event.candidate}));
		}
	};
	
	//https://www.html5rocks.com/en/tutorials/webrtc/infrastructure/
	//https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Connectivity
	//Start the connection attempt by hosting
	localConnection.createOffer() //3. create an SDP (Session Description Protocol) blob describing the connection we want to make
		.then(offer => {
			localConnection.setLocalDescription(offer); //4. configure the local end of the connection.
			//TODO //5. ask STUN servers to generate the ice candidates
			makeAjaxCall(
				'http://slime.glenwatson.me/serverPost.php?unique=1234',
				'POST',
				JSON.stringify(offer)
			); //6. uses the signaling server to transmit the offer.
			// start polling for an answer
			var cancelFunction = startPollingSignalingServer('1234', (newMessage) => {
				if (newMessage.type === 'ice_candidate') {
					localConnection.addIceCandidate(new RTCIceCandidate(newMessage.candidate));
				} else if (newMessage.type === 'answer') { //12. The caller receives the answer.
					localConnection.setRemoteDescription(new RTCSessionDescription(newMessage)) //13. Call setRemoteDescription() to set the answer as the remote description for its end of the call. It now knows the configuration of both peers.
						.then(() => console.log('host is connected'))
						//.then(() => cancelFunction()) // stop polling for message from the signaling server
						.catch((e) => console.error(e));
				} else {
					console.error("I didn't expect this message type", newMessage.type);
				}
			}); 
		})
		
}
function joinExisting() {
	localConnection = new RTCPeerConnection({iceServers: STUN_SERVERS});
	localConnection.ondatachannel = receiveChannelCallback;
	localConnection.onicecandidate = function(event) {
		console.log('onicecandidate', event);
		if (event.candidate) {
			makeAjaxCall(
				'http://slime.glenwatson.me/serverPost.php?unique=5678',
				'POST',
				JSON.stringify({type:'ice_candidate', candidate: event.candidate}));
		}
	};
	// start polling for an offer
	var cancelFunction = startPollingSignalingServer('5678', (newMessage) => {
		if (newMessage.type === 'ice_candidate') {
			localConnection.addIceCandidate(new RTCIceCandidate(newMessage.candidate));
		} else if (newMessage.type === 'offer') { 
			localConnection.setRemoteDescription(new RTCSessionDescription(newMessage)) //7. Receive the offer and calls RTCPeerConnection.setRemoteDescription() to record it as the remote description (the description of the host)
				.then(() => localConnection.createAnswer()) //8-9. Create an answer by calling RTCPeerConnection.createAnswer()
				.then((answer) => {
					localConnection.setLocalDescription(answer); //10. Call RTCPeerConnection.setLocalDescription(), passing in the created answer, to set the answer as its local description. The recipient now knows the configuration of both ends of the connection.
					makeAjaxCall(
						'http://slime.glenwatson.me/serverPost.php?unique=5678',
						'POST',
						JSON.stringify(answer)
					) //11. Use the signaling server to send the answer to the caller.
				})
				.then(() => console.log('joiner is connected'))
				// TODO Do we still need to continue polling (e.g. for ICE) after an offer is complete?
				//.then(() => cancelFunction()) // stop polling for message from the signaling server
				.catch((e) => console.error(e));
		} else {
			console.error("I didn't expect this message type", newMessage.type);
		}
	});
}
/**
 * @param clientId The unique client ID for this browser session
 * @param messageCallback Called for each message received
 * @return A function the caller uses to stop polling
 */
function startPollingSignalingServer(clientId, messageCallback) {
	var delay = 1000;
	var cancelled = false;
	function doPoll() {
		console.log('polling with delay', delay);
		setTimeout(() => {
			makeAjaxCall(
				'http://slime.glenwatson.me/serverGet.php?unique=' + clientId,
				'POST'
			).then((response) => {
				if (response) {
					var json = JSON.parse(response);
					if (json.retry) {
						//server controlled retry delay
						delay = json.retry;
					} else {
						console.log('Got an answer!');
						messageCallback(json);
					}
				}
				if (!cancelled) {
					doPoll();
				}
			}).catch((e) => console.error(e));
		}, delay);
	};
	doPoll();
	return () => {cancelled = true;};
}
function makeAjaxCall(url, method, data) {
	var xhr = new XMLHttpRequest();
	var promise = new Promise((resolve, reject) => {
		xhr.onload = function() {
			if (xhr.status === 200) {
				// If successful, resolve the promise by passing back the xhr response
				resolve(xhr.response);
			} else {
				// If it fails, reject the promise with a error message
				reject(Error('Image did not load successfully; error code:' + xhr.statusText));
			}
		};
		xhr.onerror = function() {
			// Also deal with the case when the entire request fails to begin with
			// This is probably a network error, so reject the promise with an appropriate message
			reject(Error('There was a network error.'));
		};
	});
	xhr.open(method, url, true);
	xhr.send(data);
	return promise;
}

function receiveChannelCallback(event) {
	console.log('remote ondatachannel', event);
	dataChannel = event.channel;
	dataChannel.onmessage = handleReceiveMessage;
	dataChannel.onopen = handleDataChannelStatusChange;
	dataChannel.onclose = handleDataChannelStatusChange;
}
function handleDataChannelStatusChange(event) {
	console.log('local handleDataChannelStatusChange', event);
	if (!dataChannel) {
		return;
	}
	var state = dataChannel.readyState;

	if (state === "open") { //finished establishing the link between the two peers
		messageInputBox.disabled = false;
		messageInputBox.focus();
		sendButton.disabled = false;
		disconnectButton.disabled = false;
		connectButton.disabled = true;
	} else { //"closed"
		messageInputBox.disabled = true;
		sendButton.disabled = true;
		connectButton.disabled = false;
		disconnectButton.disabled = true;
	}
}
function disconnectPeers() {
	console.log('disconnecting peers');
	// Close the RTCDataChannels if they're open.
	dataChannel.close();
	
	// Close the RTCPeerConnections
	localConnection.close();

	dataChannel = null;
	localConnection = null;
	
	// Update user interface elements
	connectButton.disabled = false;
	disconnectButton.disabled = true;
	sendButton.disabled = true;
	messageInputBox.value = "";
	messageInputBox.disabled = true;
}
function sendMessage() {
	var message = messageInputBox.value;
	dataChannel.send(message);
	appendMessageToRecieveBox('You: ' + message);
	
	messageInputBox.value = "";
	messageInputBox.focus();
}
function handleReceiveMessage(event) {
	console.log('recieve channel onmessage', event);
	appendMessageToRecieveBox(event.data);
}
function appendMessageToRecieveBox(message) {
	var el = document.createElement("p");
	var txtNode = document.createTextNode(message);
	
	el.appendChild(txtNode);
	receiveBox.appendChild(el);
}
function handleLocalAddCandidateSuccess() {
	connectButton.disabled = true;
}

function handleRemoteAddCandidateSuccess() {
	disconnectButton.disabled = false;
}
		</script>
	</body>
</html>