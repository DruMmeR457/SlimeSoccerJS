<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas 
{
    border:1px solid #d3d3d3;
    background-color: #f1f1f1;
}
</style>
</head>
<body onload="startGame()">
<script>

var redSlime, blueSlime, soccerBall;

function startGame() 
{
    myGameArea.start();
    redSlime = new player(30, 30, "red", 448, 0);
	blueSlime = new player(30, 30, "blue", 2, 0);
	//redGoal = new player(60, 10, "orange", 0, 210);
	//blueGoal = new player(60, 10, "green", 420, 210);
	soccerBall = new ball(15, 15, "yellow", 150, 150, 0.9)
}

var myGameArea = 
{
    canvas : document.createElement("canvas"),
    start : function() 
	{
        this.canvas.width = 480;
        this.canvas.height = 270;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
		this.interval = setInterval(updateGameArea, 17);
		window.addEventListener('keydown', function (e) 
		{
			myGameArea.keys = (myGameArea.keys || []);
			myGameArea.keys[e.keyCode] = true;
		})
		window.addEventListener('keyup', function (e) 
		{
			myGameArea.keys[e.keyCode] = false;
		})
    },
	
	clear : function() 
	{
		this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
	}
}

function player(width, height, color, x, y) 
{
    this.width = width;		//entity width
    this.height = height;	//entity height
    this.x = x;				//x-coordinate
    this.y = y;				//y-coordinate
	this.radius = 25;		//size of the slime player
	this.speedX = 0;		//speed travelling horizontally	
	this.speedY = 0;		//speed travelling vertically
	this.gravity = 0.08;
	this.update = function()	//puts object on canvas
	{
		ctx = myGameArea.context;
		ctx.fillStyle = color;
		ctx.beginPath();
		ctx.arc(this.x, this.y, this.radius, 0, Math.PI, true);
		ctx.fill();
	}
	this.newPos = function()	//updates x and y-coords for object
	{
		this.speedY += this.gravity;
		this.x += this.speedX;
		this.y += this.speedY;
		this.hitBottom();
	}
	this.hitBottom = function()	//defines bottom of screen behavior
	{
		var bottomScreen = myGameArea.canvas.height;
		if (this.y > bottomScreen) 
		{
			this.y = bottomScreen;
			this.speedY = 0;
		}
	}
}

function ball(width, height, color, x, y, bounce) 
{
    this.width = width;		//entity width
    this.height = height;	//entity height
    this.x = x;				//x-coordinate
    this.y = y;				//y-coordinate
	this.radius = 5;		//size of the ball
	this.speedX = 0;		//speed travelling horizontally
	this.speedY = 0;		//speed travelling vertically
	this.gravity = 0.05;	
	this.bounce = bounce;	//how high the ball bounces
	this.update = function()	//puts object on canvas
	{
		ctx = myGameArea.context;
		ctx.fillStyle = color;
		ctx.beginPath();
		ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
		ctx.fill();
	}
	this.newPos = function()	//updates x and y-coords for object
	{
		this.speedY += this.gravity;
		this.x += this.speedX;
		this.y += this.speedY;
		this.hitBottom();
	}
	this.hitBottom = function()	//defines bottom of screen behavior
	{
		var bottomScreen = myGameArea.canvas.height;
		if (this.y > bottomScreen) 
		{
			this.y = bottomScreen;
			this.speedY = -(this.speedY * this.bounce);
		}
	}
}

function redMoveLeft() 
{
	redSlime.speedX -= 1;		//red movement speed left
}

function redMoveRight() 
{
	redSlime.speedX += 1;		//red movement speed right
}

function redJump()
{
	var bottomScreen = myGameArea.canvas.height;
	if (redSlime.y == bottomScreen) {
		redSlime.speedY -= 3;
	}
}

function blueMoveLeft() 
{
	blueSlime.speedX -= 1;		//blue movement speed left
}

function blueMoveRight() 
{
	blueSlime.speedX += 1;		//blue movement speed right
}

function blueJump()
{
	var bottomScreen = myGameArea.canvas.height;
	if (blueSlime.y == bottomScreen) {
		blueSlime.speedY -= 3;
	}
}

function redStopMove()
{
	redSlime.speedX = 0;
}

function blueStopMove()
{
	blueSlime.speedX = 0;
}

function updateGameArea() {
  redStopMove();
  blueStopMove();
  if (myGameArea.keys && myGameArea.keys[37]) {redMoveLeft(); }  	//left
  if (myGameArea.keys && myGameArea.keys[39]) {redMoveRight(); }	//right
  if (myGameArea.keys && myGameArea.keys[38]) {redJump(); }  		//jump
  if (myGameArea.keys && myGameArea.keys[65]) {blueMoveLeft(); } 	//left
  if (myGameArea.keys && myGameArea.keys[68]) {blueMoveRight(); }	//right
  if (myGameArea.keys && myGameArea.keys[87]) {blueJump(); } 		//jump
  redSlime.newPos();		//update blue's location
  blueSlime.newPos();		//update blue's location
  soccerBall.newPos();
  collision(redSlime, soccerBall);
  collision(blueSlime, soccerBall);
  myGameArea.clear();		//clear game area
  redSlime.update();		//print blue's new location
  blueSlime.update();		//print blue's new location
  soccerBall.update();
}

/**
 * Calculate collisions between a slime player and the soccer ball
 * @param slime The player object
 * @param soccerBall The ball object
 */
function collision(slime, soccerBall) {
  // Check if the slime player and soccerBall are touching or overlapping
  var distanceBetweenObjects = distantBetween(slime, soccerBall);
  var overlap = (slime.radius + soccerBall.radius) - distanceBetweenObjects;
  if (overlap >= 0) {
	
	var collisionVectorX = slime.x - soccerBall.x;
	var collisionVectorY = slime.y - soccerBall.y;
	line(soccerBall.x, soccerBall.y, collisionVectorX + soccerBall.x, collisionVectorY + soccerBall.y, '#000');

	//Normalize the vector.
	//These numbers tell us the direction of the collision
	var normalizedCollisionVectorX = collisionVectorX / distanceBetweenObjects;
	var normalizedCollisionVectorY = collisionVectorY / distanceBetweenObjects;

	//Find the side that the collision is occurring on
	soccerBall.x < slime.x ? xSide = 1 : xSide = -1;
	soccerBall.y > slime.y ? ySide = 1 : ySide = -1;

	//Move the soccer ball out of the collision by multiplying
	//the overlap with the normalized vector and adding it to
	//the circles' positions
	soccerBall.x = soccerBall.x + (normalizedCollisionVectorX * overlap * xSide);
	soccerBall.y = soccerBall.y + (normalizedCollisionVectorY * overlap * ySide);
	
	//1. Calculate the collision surface's properties

	//Find the surface vector's normal (perpendicular line)
	surfaceVectorsNormalX = collisionVectorY;
	surfaceVectorsNormalY = -collisionVectorX;
	line(
		soccerBall.x - surfaceVectorsNormalX,
		soccerBall.y - surfaceVectorsNormalY,
		surfaceVectorsNormalX + soccerBall.x,
		surfaceVectorsNormalY + soccerBall.y,
		'#0f0');

	//2. Bounce the soccer ball off the surface vector

	//Find the dot product between the soccer ball and the surface vector
	var dp1 = soccerBall.speedX * normalizedCollisionVectorX + soccerBall.speedY * surfaceVectorsNormalY;

	//Project the soccer ball's speed onto the collision surface
    //bounceProjectionX = dp1 * normalizedCollisionVectorX;
    //bounceProjectionY = dp1 * normalizedCollisionVectorY;

	//Find the dot product of the soccer ball's speed and the surface's normal (surfaceVectorsNormalX and surfaceVectorsNormalY)
	var dp2 = 
	    soccerBall.speedX * (surfaceVectorsNormalX / distanceBetweenObjects) + 
		soccerBall.speedY * (surfaceVectorsNormalY / distanceBetweenObjects);
	//Find the dot product between the slime player and the surface
	var dp3 = 
	    slime.speedX * normalizedCollisionVectorX + 
	    slime.speedY * normalizedCollisionVectorY;

	//4. Calculate the bounce vectors
	//Project the soccer ball's speed onto the surface's normal
	// c1.bounce.x = p1B.x + p2A.x;
	var soccerBallBounceX = (dp2 * (surfaceVectorsNormalX / distanceBetweenObjects)) + (dp3 * normalizedCollisionVectorX);
	// c1.bounce.y = p1B.y + p2A.y;
	var soccerBallBounceY = (dp2 * (surfaceVectorsNormalY / distanceBetweenObjects)) + (dp3 * normalizedCollisionVectorY);

	//Add the bounce vector to the soccer ball's speed
	soccerBall.speedX = soccerBallBounceX;
	soccerBall.speedY = soccerBallBounceY;
    
	// We don't change the player's position because the soccer ball should bounce off the player.
  }
}

function line(x1, y1, x2, y2, color) {
ctx = myGameArea.context;
ctx.strokeStyle = color;
ctx.beginPath();
ctx.moveTo(x1, y1);
ctx.lineTo(x2, y2);
ctx.closePath();
ctx.stroke();
}

/**
 * Calculate the distance between a slime player and the soccer ball
 * @param slime The player object
 * @param soccerBall The ball object
 */
function distantBetween(slime, soccerBall) {
	return Math.sqrt(
	    Math.pow(slime.x - soccerBall.x, 2) + 
	    Math.pow(slime.y - soccerBall.y, 2)
	);
}

</script>

</body>
</html>